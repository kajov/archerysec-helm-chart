# Hooks
hooks:
  # Enable or dissable hooks
  enabled: true

replicaCount: 1

PodDisruptionBudget:
  enable: false

# Integrate vault mutating webhook to the chart
vault:
  enabled: false
  security:
    mutate_configmap: true
    vault_addr: http://qc-vault.qc-iam.svc.cluster.local:8200
    vault_role: archery
    vault_path: kubernetes
    vault_skip_verify: true

# Arachni web crawler
arachni:
  # Enable or dissable arachni deployment
  deploy:
    enabled: true

  # Arachni Service ports
  service:
    apiPort: 7331
    httpPort: 9292

  # Arachni Image repo
  image: ahannigan/docker-arachni
  tag: latest
  imagePullPolicy: IfNotPresent
  restartPolicy: Always

  # Arachni deployment resources minimum suggested req. mem=2GiB cpu=1
  resources:
    limits:
      cpu: 1
      memory: 512Mi
    requests:
      cpu: 1
      memory: 128Mi

  # will services be created
  services:
    service: true

  serviceType: ClusterIP

postgres_db:
  # Enable or dissable deployment for postgres_db
  deployment:
    enabled: true

    image: postgress
    tag: 10.1-alpine
    imagePullPolicy: IfNotPresent
    restartPolicy: Always
    resources:
      limit:
        cpu: 1
        memory: 512Mi
      requests:
        cpu: 1
        memory: 126Mi

    env:
      - PDB_PASSWORD=
      - DB_USER=
      - DB_NAME=
      - DB_HOST=
      - DJANGO_SETTINGS_MODULE=arhcerysecurity.settings.development
      - DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY:-"uYvGz4IbkM9CZEcM9lMmx40Sj0ycXiVE"}
      - DJANGO_DEBUG=0
      - EMAIL_HOST=mailhog
      - EMAIL_PORT=1025

  # Create Persistant volume claim, for development each restart will wipe data out
  # it is necessary that production has persistence enabled.
  persistence:
    enabled: true

  mountPath: []

# OpenVas deployment

openvas:
  deployment:
    enabled: true

  images: avhost/docker-openvas
  tag: latest
  restartPolicy: Always
  pullPolicy: IfNotPresent

  ports:
    https_web: 443
    api_1: 9390
    api_2: 9392

  resorces:
    limit:
      cpu: 1
      memory: 512Mi
    requests:
      cpu: 1
      memory: 215Mi

mailhog:
  # Enabled mailhog deployment
  deployment:
    enabled: true

  image:
    repository: mailhog/mailhog
    tag: ""
    pullPolicy: IfNotPresent

  nameOverride: ""
  fullnameOverride: ""

  service:
    annotations: {}
    clusterIP: ""
    externalIPs: []
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    type: ClusterIP
    port:
      http: 8025
      smtp: 1025
    nodePort:
      http: ""
      smtp: ""

  securityContext:
    runAsUser: 1000
    fsGroup: 1000
    runAsNonRoot: true

  ingress:
    enabled: false
    annotations:
      {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: mailhog.example.com
        paths: ["/"]

    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  auth:
    enabled: false
    existingSecret: ""
    fileName: auth.txt
    fileContents: ""

  podAnnotations: {}

  podLabels: {}

  extraEnv: []

  resources:
    {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  affinity: {}

  nodeSelector: {}

  tolerations: []

### appData ###
identifier:
  clusterId: autogenerated
  tenantId: autogenerated
  tenantName: autogenerated
  spaceId: autogenerated
  spaceName: autogenerated
  appid: autogenerated
  appName: archerysec

### create cluster role binding
rbac:
  create: true
